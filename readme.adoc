= Prometheus AWS Deployment

== Goal

The goal of this project is to deploy a Prometheus installation in AWS using Terraform. Prometheus should use automatic EC2 discovery to discover new EC2 nodes. This project firmly follows infrastructure of code principle. Except where otherwise noted, no pre-existent infrastructure is needed.

== Prerequisites

The following assumptions are made about the environment where this deployment can be used

. All Deployments are done in an AWS VPC with direct internet access, so no Proxy is needed.
. I just assume, there exists an IAM user with the necessary permissions to run all the terraform commands. Of course setting this up securely in reality might be a task on its own. In my demo account, I just use an IAM user with the `AdministratorAccess` policy.

== Out of scope

The following things are out of scope for this project, but could be required to actually use it in a production environment

. High availability of the Prometheus installation
. Secure VPC Setup
. Store tfstate files
.. I cannot check them into source control, as these files also contain secrets. While it seems possible to encrypt them, it would probably be wiser to store the state in some other backend. I just added the files to .gitignore for the time being.
. While I would never deploy any http components without the use of TLS, I was reluctant to spent any time on that in this example. It is relatively easy though, to use an ELB with an AWS certificate. But this requires dns with route53 and a correct dns zone. Nothing I wanted to set my focus on.
. Persistant Storage for Prometheus
.. Of course, this is a deal breaker. I learned at the "end", that Fargate does not support persistent storage. This means, that Fargate is not the right tool for the job, as persistence for Prometheus is probably a hard requirement. I would probably move away from ecs alltogether and just deploy the docker container on an ec2 instance with a docker deamon installed, where it would be easy to mount an ebs volume (or efs, if multi-az is required) and mount that to the docker container. Or even better, deploy it on an already existent Kubernetes cluster.

== Architecture

=== Prometheus
The prometheus server is deployed as an ECS Fargate Container. The base of this deployment is a locally testable Dockerfile that is based on the official Prometheus Docker Image. The configuration is part of the Docker Image, with the IAM Credentials being injected through environment variables, that in turn are supplied by the AWS Secrets Manager.

=== EC2-Node
The node itself if just a simple ec2 node that does nothing, but expose some metrics on port 9100. It resides in a public subnet, mainly to allow me to access it via ssh (of course usually we have a better concept for this, like a bastion host, or a vpn). In general, the installation code of the node-exporter should be reusable, either in form of a base image that is shared, or in form of a reusable script, that is just included in the user data of the ec2 nodes.

=== Network
While the network architecture is basic, it shows some of the things that are possible with the usage of Amazon VPC.

Everything is placed in public subnets. Of course this is not a desired state, but it allows to circumvent the rather costly NAT Gateways (for a Free Tier account at least ;)).

Security Groups limit the access of the metrics endpoints in a way, that only the prometheus instace is allowed to access Port 9100 of the ec2 nodes. This is achieved by using an ingress Rule that references the ingress security group of the prometheus instance.

== References

Using several resources on the web, the following were helpful in particular, and some of the code is copied from there:

https://hackernoon.com/introduction-to-aws-with-terraform-7a8daf261dc0
https://www.robustperception.io/automatically-monitoring-ec2-instances
https://kbild.ch/blog/2019-02-18-awsprometheus/
https://github.com/Oxalide/terraform-fargate-example